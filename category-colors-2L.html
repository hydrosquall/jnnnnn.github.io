<!DOCTYPE html>
<meta charset="utf-8">
<!-- 


License: Public Domain.
Original Author: Jonathan Newnham
-->
<style>

.axis {
  stroke: #999;
  stroke-opacity: .5;
  fill-opacity: 0;
  stroke-width: 1;
}

.mo {
  font-family: Consolas, Inconsolata, "Courier New", Courier, monospace;
}

p { max-width: 40em; }

</style>
<body>
<h1 style="display:inline">Category Color Generator</h1>
<div></div>
<div id="controls" style="float:right; padding:1em">
  <form id="fc" onsubmit="force.start(); return false;" style="display:inline">
   
    L1:<input id="lrange" type="range" min="0" max="100" value="60" step="1" oninput="initcolors();" />
    <br />
    L2:<input id="lrange2" type="range" min="0" max="100" value="80" step="1" oninput="initcolors();" />
    <br />
    Grid:<input id="gridstep" type="range" min="6" max="60" value="20" step="1" oninput="initcolors();" />
    <br />
    <input type="button" value="Reset" onclick="initcolors();"/>
    <input type="button" value="Sort" onclick="startsort();"/>
    <input type="button" value="Pause" onclick="sorting=false;"/>
  </form>
</div>
<svg id="graph" style="display:inline"></svg>
<div id="status" style="float:right"></div>
<div id="sortedlist" class="mo"></div>
<div id="about" style="display:inline">
<h3>About</h3>
<p>This page is for generating a set of colours to use for representing categories of graphs.</p>
<p>It is based on a <span style="font-weight:bold">Lab color space</span>, as implemented by d3js. The special thing about this color space is that colours are separated by perceptual distance -- read more in the wikipedia article. This allows us to easily choose colours that are a large perceptual distance apart. It also allows us to choose many colours that are the <span style="font-family:italic">same</span> distance apart, for consistent contrast with a background, or colors that are all the same lightness, for pleasing consistency and avoiding distraction.
</p>
</div>


<script src="d3.v3.min.js"></script>

<script>

var width = 800;
var height = 800;

var svg = d3.select("svg#graph")
    .attr("width", width)
    .attr("height", height);

var layer0 = svg.append("g").attr("id", "layer0"); // for background stuff (link paths, text)
var layer1 = svg.append("g").attr("id", "layer1"); // for background stuff (link paths, text)

var x0 = width / 2;
var y0 = height / 2;
var x0_g = x0; // centre of gravity
var y0_g = y0; // centre of gravity

var sorting = false;

var sorted_grid_n = 30;

var scalefactor = 3;

layer0.selectAll(".backrect").data([0]).enter().append("rect")
      .classed("backgrect", true)
      .attr("height", height)
      .attr("width", width)
      .style("fill", "white");
layer0.selectAll(".axis").data([
          [[0, height/2],[width, height/2]],
          [[width/2, 0],[width/2, height]],
      ])
      .enter().append("path")
        .attr("d", function(d) { return d3.svg.line().interpolate("monotone")(d); })
        .style("stroke-width", "1")
        .classed("axis", true);

var ds = []; // data array: list of (x,y) pairs and d3js internals
var d_sorteds = [];

function validcolor(lab) {
  var rugub = lab.rgb();
  return ((0 < rugub.r) && (rugub.r < 256) 
      && (0 < rugub.g) && (rugub.g < 256) 
      && (0 < rugub.b) && (rugub.b < 256));
}

function coord_to_labcolor(x, y, L) {
  return d3.lab(L, (x-x0)/scalefactor, (y0-y)/scalefactor);
}

function initcolors() {
  sorting = false;
  var L1 = document.getElementById("lrange").value;
  var L2 = document.getElementById("lrange2").value;
  document.getElementById("sortedlist").innerHTML = "";
  var gridStep = parseInt(document.getElementById("gridstep").value);
  document.getElementById("status").innerHTML = "L1=" + L1 + " L2=" + L2 + "<br />Gridstep=" + gridStep;
  ds = [];
  d_sorteds = [];  
  for (x = 0; x < width; x+=gridStep) {
    for (y = 0; y < height; y+=gridStep) {      
      var lab = coord_to_labcolor(x, y, L1);
      if (validcolor(lab)) {
        ds.push({ 
            lab: lab,
            x: x,
            y: y,
            r: 5
        });
      }
      var lab = coord_to_labcolor(x, y, L2);
      if (validcolor(lab)) {
        ds.push({ 
            lab: lab,
            x: x,
            y: y,
            r: 3
        });
      }
    }
  }

  layer1.selectAll(".posnode").remove();
  var nodes = layer1.selectAll(".posnode")
      .data(ds)
    .enter().append("circle")
      .classed("posnode", true)
      .attr("cx", 0)
      .attr("cy", 0)
      .attr("r", function(d) { return d.r; })
      .style("fill", function(d) { return d.lab; })
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });  
}

function startsort() {
  sorting = true;
  sortcolors();
}

// Order colours by greatest distance from all other selected colors.
function sortcolors() {
  // faster ways of doing this include
  //  - a quadtree of d_sorteds for the nearest-neighbour search
  var d_new = find_distant_node();
  if (sorting && d_new.nearest > 0)
  {        
    d_new.sorted = true;
    var i = d_sorteds.length;
    d_sorteds.push(d_new);
    move_sorted_node(d_new, i);
    add_to_sorted_list(d_new.lab);
    setTimeout(sortcolors, 500 * d3.ease("quad")(1-i/50));
  }
}

function add_to_sorted_list(lab)
{
  document.getElementById("sortedlist").innerHTML += "\""+lab.rgb()+"\", ";
}

// find the node that is furthest away from all the currently selected (sorted) nodes.
function find_distant_node()
{
  ds.forEach(function(d) {
    if (d.sorted) {
      d.nearest = 0;
      return;
    }
    d.nearest = 1000000;
    var sq = function(x) { return x * x; }
    d_sorteds.forEach(function(d_sorted) {
      dist = (sq(d.lab.a - d_sorted.lab.a)
            + sq(d.lab.b - d_sorted.lab.b)
            + sq(d.lab.l - d_sorted.lab.l));
      if (dist < d.nearest)
        d.nearest = dist;
    });
  });
  ds.sort(function(d1, d2) { return d2.nearest - d1.nearest;});
  return ds[0];
}

// pretty transition -- move to new sorted location.
function move_sorted_node(d_selected, i)
{  
  var iy = Math.floor(i/sorted_grid_n);
  var sorted_grid_step = width / (sorted_grid_n + 1);
  var x_new = sorted_grid_step * (1+(i % sorted_grid_n));
  var y_new = sorted_grid_step * (1+iy);
  if (iy % 2)
    x_new = width - x_new;
  var element = d3.selectAll(".posnode")
    .filter(function(d) { return d == d_selected; })
    .transition()
      .duration(1000)
      .attr("transform", "translate(" + x_new + "," + y_new + ")")
      .attr("r", sorted_grid_step / 3);
}



initcolors();

</script>
