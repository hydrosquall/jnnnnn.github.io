<!DOCTYPE html>
<meta charset="utf-8">
<style>

.nodepos {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
  fill-opacity: 0;
  stroke-width: 3;
}

.axis {
  stroke: #999;
  stroke-opacity: .5;
  fill-opacity: 0;
  stroke-width: 1;
}

.transitionnode {
  text-anchor: middle;
  font-size: 8pt;
  font-family: Calibri, Sans, sans-serif;
}

.transitionnodeselected {
  fill: #00B;
  font-size: 20pt;
}

.posnode {
  font-weight: bold;
  font-family: Times New Roman, Times, Calibri, Sans, sans-serif;
  font-variant: normal;
}

div#explanation h3 {
  display:inline;
}
div#explanation .historystate {
  display:inline;
  color: #888;
}
div#explanation .historyarrow, p{
  display:inline;
  padding: .5em;
}

.posnodeselected {
  font-size: 20pt;
}

</style>
<body>
<h1>State transition explorer</h1>
<svg id="graph"></svg>
<div id="explanation">
<script src="d3.v3.js"></script>
<script>

// jargon:
//   * sd : state: a resting state
//   * td : transition: a way of transitioning between states
//   * link: a physics object of the force graph. A spring between a state and a transition.

// http://bl.ocks.org/mbostock/5649592 stroke dash interpolation
// http://bl.ocks.org/mbostock/3310323 line interpolation
// http://bl.ocks.org/gka/5145845 circular graph of links
// http://cs.brown.edu/people/jcmace/d3/graph.html?id=small.json explore a dag

var width = 1100 || d3.select("body")[0][0].scrollWidth || 1000,
    height = 700 || d3.select("body")[0][0].scrollHeight || 800;

var color = d3.scale.category20();

var gravity = 0.01;

var force = d3.layout.force()
    .charge(-50)
    .linkDistance(80)
    .linkStrength(0.3)
    // .gravity(0.5) // set later on
    .size([width, height]);

function strong_gravity(alpha) {
  return function(d) {
    d.x += (width/2 - d.x) * 0.1;
    d.y += (height/2 - d.y) * 0.1;
  }
}

// a function that pushes pre-transitions to the left and post-transitions to the right.
function separate_gravity(alpha) {
  return function(d) {
    if (d == state_node_selected) 
      return; // otherwise jiggle

    d.x += d.selected_next * alpha;  // bool coerced to 0 or 1
    d.x -= d.selected_prev * alpha;  // bool coerced to 0 or 1

    // push to vertical edges
    if (d.selected_prev && d.selected_next)
      d.y += (((d.y > (height / 2)) * 2) - 1) * alpha * force.gravity() / 0.03;
  }
}


var svg = d3.select("svg#graph")
    .attr("width", width)
    .attr("height", height);

var layer0 = svg.append("g").attr("id", "layer0"); // for background stuff (link paths, text)
var layer1 = svg.append("g").attr("id", "layer1"); // for everything else (nodes)

var state_data; // states (graph nodes)
var state_data_selected; // the currently-selected state
var transition_data; // transitions between states (provide a path between nodes)
var move_history = [];
var move_history_current; // undo/redo pointer
var move_history_next_id = 0;

function get_link_color(d) {
  if (d.selected_next && d.selected_prev) return "#000";
  if (d.selected_next) return "#040";
  if (d.selected_prev) return "#800";
  return "#00A"; 
}

function add_history(new_move_td) {
  // need a new data object to prevent accidental data join collisions in history list
  // (otherwise if the same move is in the list more than once, joins will be out of order)
  var hd = {
    "key": move_history_next_id++,
    "td": new_move_td
  };

  if (move_history.length > 5) move_history.pop();
  move_history.unshift(hd);

  var history_elements = d3.selectAll("div#explanation").selectAll("div")
      .data(move_history, function(hd) { return hd.key; });

  var new_history = history_elements
    .enter()
    .insert("div");
  new_history.append("h3")
      .classed("historymove", true)
      .text(function(hd) { return hd.td.name; });
  new_history.append("h3")
      .classed("historystate", true)
      .classed("historyarrow", true)
      .text("â†’");
  new_history.append("h3")
      .classed("historystate", true)
      .style("color", color(hd.td.end))
      .text(function(hd) { return hd.td.end; });
  new_history.append("p")
      .classed("historyextra", true)
      .text(function(hd) { return hd.td.description; });
  new_history.on("click", function(hd) {
    select_transition(hd.td);
  });
  history_elements
    .exit()
    .transition()
      .duration(300)
      .style("opacity", 0)
      .remove();
}

// focus on the given transition (and associated end state)
// take data because element might not exist until after state is selected
function select_transition(new_td) {  
  var new_state_element = d3
    .selectAll(".posnode")
    .filter(function(sd) { return sd == new_td.physics_end.target; })
    .node();
  select_state(new_state_element);

  var new_transition_element = layer0.selectAll(".transitionnode")
    .classed("transitionnodeselected", function(td) { return td == new_td; });
}

// Move a new State node to the centre of the graph, and add links in and out of it.
function select_state(new_selected_state_element) {
  state_node_selected = new_selected_state_element.__data__;

  // remove any other selection
  svg.selectAll(".posnodeselected").classed("posnodeselected", false);

  // select the clicked node
  var current_pos_node = d3.select(new_selected_state_element);
  current_pos_node.classed("posnodeselected", true);

  // clear markers on current state
  state_data.forEach(function(sd) {
    sd.selected_next = false;
    sd.selected_prev = false;
  })

  // update data indicating selected state and transition
  transition_data.forEach(function(td) {
    td.selected_next = td.physics_start.source == new_selected_state_element.__data__;
    td.selected_prev = td.physics_end  .target == new_selected_state_element.__data__;
    if (td.selected_prev) { td.physics_start.source.selected_prev = true; }
    if (td.selected_next) { td.physics_end  .target.selected_next = true; }
  });

  var transition_data_visible = transition_data
    .filter(function(td) { return td.selected_prev || td.selected_next; });

  var transition_nodes = layer0.selectAll("g.linkgroup")
      .data(transition_data_visible, function(td) { return td.key; })      
      .classed("linknext", function(td) { return td.selected_next; })
      .classed("linkprev", function(td) { return td.selected_prev; });

  transition_nodes
    .exit()
    .remove(); // can't fade out because removing later might stuff up other transitions
  
  transition_nodes
    .selectAll(".link")
    .transition()
      .duration(750)
      .style("stroke", get_link_color); 

  // enter selection
  var new_transitions = transition_nodes
    .enter().append("g") // supposedly merges update selection
      .classed("linkgroup", true)      
      .classed("linknext", function(td) { return td.selected_next; })
      .classed("linkprev", function(td) { return td.selected_prev; })
      .on("click", transition_node_click);

  new_transitions.append("path")
      .attr("class", "link")
      .style("stroke-width", function(td) { return td.count; })
      .style("opacity", 0)

  new_transitions.append('g')
      .attr("class", "linktext")
    .append("text")
      .attr("dx", 0)
      .attr("dy", ".35em")
      .attr("class", "transitionnode")            
      .style("opacity", 0) // will fade in
      .attr("title", function(td) { return td.description })
      .text(function(td) { return td.name; });
  
  var fade = layer0.transition()
      .delay(500)
      .duration(250);
  fade.selectAll("path.link")
      .style("opacity", .3)
      .style("stroke", get_link_color);
  fade.selectAll("g.linkgroup text")
      .style("opacity", 1)
      .style("fill", get_link_color);
  
  // slow down any existing physics so the initial transitions are easier to spot
  force.alpha(0.01);
  // don't start physics straight away so we can see which move gets selected
  setTimeout(start_physics, 500);
}

function start_physics() {
  var transition_data_visible = transition_data.filter(function(td) { return td.selected_prev || td.selected_next; });
  var transition_link_data = []; // links from state to transition and transition to state. for physics simulation.
  transition_data_visible.forEach(function(td) {
    transition_link_data.push(td.physics_start);
    if (!td.nochange) // don't need two identical links for physics
      transition_link_data.push(td.physics_end);
  });

  var all_nodes = state_data.concat(transition_data_visible);
  force
    .nodes(all_nodes)
    .gravity(gravity * (1 + 0.02 * all_nodes.length))
    .links(transition_link_data)
    .start();

  var state_node = svg.selectAll("g.posnode");
  var state_node_selected = svg.selectAll("g.posnodeselected");
  var link_lines = svg.selectAll("path.link");
  var link_nodes_text = svg.selectAll("g.linktext");
  var link_nodes = svg.selectAll("g.linkgroup");

  force.on("tick", function(e) {
    // a little bit of custom physics
    link_nodes.each(separate_gravity(15 * e.alpha));
    state_node.each(separate_gravity(15 * e.alpha));
    state_node_selected.each(strong_gravity(e.alpha));
    // move the paths
    link_lines.attr("d", function(td) {
      var start_node      = td.physics_start.source;
      var transition_node = td.physics_start.target;
      var end_node        = td.physics_end.target;
      var points = [
          [start_node.x, start_node.y],
          [transition_node.x - 3*td.name.length, transition_node.y],
          [transition_node.x                   , transition_node.y],
          [transition_node.x + 3*td.name.length, transition_node.y],          
          [end_node.x, end_node.y],
      ];      
      return d3.svg.line()
          .interpolate("monotone")
          (points);
    });
    // move the text and circles
    state_node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
    // move the link text
    link_nodes_text.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  });
}

// combine multiple duplicate rows, keeping count.
function build_transitions_from_rows(state_data, csv_rows) {  
  // while we're building the array of transitions, there might be some duplicates. 
  // Use a map to keep count then return in an array after.
  var build_transitions = {}; 

  // map state name -> full data entry
  var state_map = {};  
  state_data.forEach(function(state_datum) { 
    state_map[state_datum.name] = state_datum; 
  });
  
  csv_rows.forEach(function(row) {
    var key = row.Start + "->" + row.Move + "->" + row.End;
    if (!build_transitions[key])
    {
      // here is where we construct a new transitionnode data object:
      var newtransitionnodedatum = {
        "key": key,
        "start": row.Start,
        "name": row.Move,
        "end": row.End,        
        "description": row.Description,
        "count": 1,
        "nochange": row.Start === row.End
      };

      // for physics simulation (start and end link are independent)
      newtransitionnodedatum.physics_start = {
        source: state_map[row.Start],
        target: newtransitionnodedatum // yep, circular reference
      };
      newtransitionnodedatum.physics_end = {
        source: newtransitionnodedatum, // yep, circular reference
        target: state_map[row.End]
      };

      if (state_map[row.Start] === undefined || state_map[row.End] === undefined)
          throw "Undefined state lol";

      // finished construction, save it for returning (or counting)
      build_transitions[key] = newtransitionnodedatum;
    } else {
      // this row is a duplicate; increase count instead.
      build_transitions[key].count += 1;
    }
  });

  var transition_data = [];
  for (var transition in build_transitions)
    transition_data.push(build_transitions[transition]);
  return transition_data;
}

d3.tsv("salsa_moves.txt", function(error, csv_rows) {      
  var start_states = d3.set(csv_rows.map(function(row){ return row.Start; })).values();
  var end_states = d3.set(csv_rows.map(function(row){ return row.End; })).values();
  var states = d3.set(start_states.concat(end_states)).values();
  state_data = states.map(function(state){ return {name: state}; }); 
  
  color.domain(states);

  transition_data = build_transitions_from_rows(state_data, csv_rows); 

  layer0.selectAll(".axis").data([
        [[0, height/2],[width, height/2]],
        [[width/2, 0],[width/2, height]],
    ])
    .enter().append("path")
      .attr("d", function(d) { return d3.svg.line().interpolate("monotone")(d); })
      .classed("axis", true);

  var state_node = layer1.selectAll(".posnode")
      .data(state_data)
    .enter().append("g")
      .classed("posnode", true)
      .attr("transform", function(d, i) { return "translate(" + d.x + "," + d.y + ")"; })
      .on("click", posnodeclick)      
      .call(force.drag);

  state_node.append("circle")
      .attr("cx", 0)
      .attr("cy", 0)
      .attr("r", 10)
      .style("fill", function(sd, i) { return color(sd.name); })

  state_node.append("text")
      .attr("dx", 12)
      .attr("dy", ".35em")
      .attr("class", "posnode")
      .text(function(sd) { return sd.name; });

  select_state(state_node.node()); // select the first state to start things off
});

function posnodeclick (sd)
{ 
  if (d3.event.defaultPrevented)
    return; // don't "click" if dragged.

  select_state(this);
}

function transition_node_click(td)
{
  if (d3.event.defaultPrevented)
    return; // don't "click" if dragged.  

  select_transition(td);
  add_history(td);
}

function onkeypress()
{
  // http://stackoverflow.com/questions/15261447/how-do-i-capture-keystroke-events-in-d3-force-layout
  // finding keyCodes: http://jsfiddle.net/qAHC2/292/
  switch(d3.event.keyCode) {        
    case 39: // right
      var possible_transitions = svg.selectAll("g.linknext")[0]; // all "next" transition groups
      var random_index = Math.floor(Math.random() * possible_transitions.length);
      var random_transition_data = possible_transitions[random_index].__data__;      
      select_transition(random_transition_data);
      add_history(random_transition_data);
      break;
    // case 37: // left
    // case 38: // up
    // case 40: // down
    default:
      break; 
  };
}

d3.select("body")
    .on("keydown", onkeypress);

</script>
